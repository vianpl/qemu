# hyperv.c
hyperv_hcall_vtl_enable_partition_vtl(uint64_t target_partition_id, uint8_t target_vtl, uint8_t flags) "target partition id 0x%lx, target VTL %d, flags 0x%hhx"
hyperv_hcall_vtl_enable_vp_vtl(uint64_t target_partition_id, uint32_t vp_index, uint8_t target_vtl) "target partition id 0x%lx, VP index %d, target VTL %d"
hyperv_hcall_vtl_call(uint32_t vp_index, uint8_t active_vtl, uint8_t next_vtl) "VP index %u, active vtl %u, next vtl %u"
hyperv_hcall_vtl_return(uint32_t vp_index, uint8_t active_vtl, uint8_t prev_vtl, uint64_t ctl) "VP index %u, active vtl %u, next vtl %u, ctl 0x%lx"
hyperv_hcall_vtl_upcall(uint32_t vp_index, uint8_t vtl, uint32_t vtl_event_state, uint32_t vtl_event_handled) "VP index %u, vtl %d, state 0x%x, handled %u"
hyperv_hcall_vtl_downcall(uint32_t vp_index, uint8_t vtl) "VP index %u, vtl %d"
hyperv_hcall_vtl_entry(uint32_t vp_index, uint8_t vtl, uint32_t vtl_event_state) "VP index %u, vtl %d, state 0x%x"
hyperv_hcall_vtl_poll(uint32_t vp_index, uint8_t active_vtl) "VP index %u, active vtl %u"
hyperv_hcall_vtl_interrupt(uint32_t vp, uint8_t active_vtl, uint8_t next_vtl) "VP index %u, active vtl %u, next vtl %u"
hyperv_hcall_get_set_vp_register(uint64_t partition_id, uint32_t vp_index, uint8_t input_vtl, uint16_t vtl, uint16_t count, bool set) "partition id 0x%lx, VP index %d, target VTL %u, active VTL %u, count %d, set %d"
hyperv_hcall_set_vp_register(uint32_t name, uint64_t val_low, uint64_t val_high) "name 0x%x, val_low 0x%lx, val_high 0x%lx"
hyperv_hcall_get_vp_register(uint32_t name, uint64_t val_low, uint64_t val_high) "name 0x%x, val_low 0x%lx, val_high 0x%lx"
hyperv_hcall_vtl_protection_mask(uint64_t target_partition_id, uint32_t map_flags, uint8_t target_vtl, uint16_t count) "target partition id 0x%lx, map flags 0x%x, target VTL %d, count %d"
hyperv_setup_vp_assist_page(uint32_t vp_index, uint8_t vtl, bool enable, uint64_t gpa) "VP index %d, target VTL %d, enable %d, gpa 0x%lx"
hyperv_setup_hypercall_page(uint32_t vp_index, uint8_t vtl, bool enable, uint64_t gpa) "VP index %d, target VTL %d, enable %d, gpa 0x%lx"
hyperv_handle_fault(uint32_t vp_index, int vtl, uint64_t gpa, uint64_t size, uint8_t insn_len, uint64_t flags, uint64_t prots) "VP index %d, vtl %d, gpa 0x%lx, size 0x%lx, insn len %u, flags 0x%lx, vtl prots 0x%lx"

# vmbus.c
vmbus_recv_message(uint32_t type, uint32_t size) "type %d size %d"
vmbus_signal_event(void) ""
vmbus_channel_notify_guest(uint32_t chan_id) "channel #%d"
vmbus_post_msg(uint32_t type, uint32_t size) "type %d size %d"
vmbus_msg_cb(int status) "message status %d"
vmbus_process_incoming_message(uint32_t message_type) "type %d"
vmbus_initiate_contact(uint16_t major, uint16_t minor, uint32_t vcpu, uint64_t monitor_page1, uint64_t monitor_page2, uint64_t interrupt_page) "version %d.%d target vp %d mon pages 0x%"PRIx64",0x%"PRIx64" int page 0x%"PRIx64
vmbus_send_offer(uint32_t chan_id, void *dev) "channel #%d dev %p"
vmbus_terminate_offers(void) ""
vmbus_gpadl_header(uint32_t gpadl_id, uint16_t num_gfns) "gpadl #%d gfns %d"
vmbus_gpadl_body(uint32_t gpadl_id) "gpadl #%d"
vmbus_gpadl_created(uint32_t gpadl_id) "gpadl #%d"
vmbus_gpadl_teardown(uint32_t gpadl_id) "gpadl #%d"
vmbus_gpadl_torndown(uint32_t gpadl_id) "gpadl #%d"
vmbus_open_channel(uint32_t chan_id, uint32_t gpadl_id, uint32_t target_vp) "channel #%d gpadl #%d target vp %d"
vmbus_channel_open(uint32_t chan_id, uint32_t status) "channel #%d status %d"
vmbus_close_channel(uint32_t chan_id) "channel #%d"

# hv-balloon
hv_balloon_state_change(const char *tostr) "-> %s"
hv_balloon_incoming_version(uint16_t major, uint16_t minor) "incoming proto version %u.%u"
hv_balloon_incoming_caps(uint32_t caps) "incoming caps 0x%x"
hv_balloon_outgoing_unballoon(uint32_t trans_id, uint64_t count, uint64_t start, uint64_t rempages) "posting unballoon %"PRIu32" for %"PRIu64" @ 0x%"PRIx64", remaining %"PRIu64
hv_balloon_incoming_unballoon(uint32_t trans_id) "incoming unballoon response %"PRIu32
hv_balloon_outgoing_hot_add(uint32_t trans_id, uint64_t count, uint64_t start) "posting hot add %"PRIu32" for %"PRIu64" @ 0x%"PRIx64
hv_balloon_incoming_hot_add(uint32_t trans_id, uint32_t result, uint32_t count) "incoming hot add response %"PRIu32", result %"PRIu32", count %"PRIu32
hv_balloon_outgoing_balloon(uint32_t trans_id, uint64_t count, uint64_t rempages) "posting balloon %"PRIu32" for %"PRIu64", remaining %"PRIu64
hv_balloon_incoming_balloon(uint32_t trans_id, uint32_t range_count, uint32_t more_pages) "incoming balloon response %"PRIu32", ranges %"PRIu32", more %"PRIu32
hv_balloon_our_range_add(uint64_t count, uint64_t start) "adding our range %"PRIu64" @ 0x%"PRIx64
hv_balloon_remove_response(uint64_t count, uint64_t start, unsigned int both) "processing remove response range %"PRIu64" @ 0x%"PRIx64", both %u"
hv_balloon_remove_response_hole(uint64_t counthole, uint64_t starthole, uint64_t countrange, uint64_t startrange, uint64_t starthpr, unsigned int both) "response range hole %"PRIu64" @ 0x%"PRIx64" from range %"PRIu64" @ 0x%"PRIx64", before our start 0x%"PRIx64", both %u"
hv_balloon_remove_response_common(uint64_t countcommon, uint64_t startcommon, uint64_t countrange, uint64_t startrange, uint64_t counthpr, uint64_t starthpr, uint64_t removed, unsigned int both) "response common range %"PRIu64" @ 0x%"PRIx64" from range %"PRIu64" @ 0x%"PRIx64" with our %"PRIu64" @ 0x%"PRIx64", removed %"PRIu64", both %u"
hv_balloon_remove_response_remainder(uint64_t count, uint64_t start, unsigned int both) "remove response remaining range %"PRIu64" @ 0x%"PRIx64", both %u"
hv_balloon_map_slot(unsigned int idx, unsigned int total_slots, uint64_t offset) "mapping memslot %u / %u @ 0x%"PRIx64
hv_balloon_unmap_slot(unsigned int idx, unsigned int total_slots, uint64_t offset) "unmapping memslot %u / %u @ 0x%"PRIx64
